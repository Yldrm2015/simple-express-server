<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bot Detection System Tester</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .panel h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .metric {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }
        .metric-name {
            flex: 1;
            font-weight: bold;
        }
        .metric-value {
            flex: 2;
        }
        .passed {
            color: green;
        }
        .failed {
            color: red;
        }
        .neutral {
            color: #666;
        }
        .progress-bar {
            height: 20px;
            background-color: #eee;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }
        .progress-value {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        #status-indicator {
            font-size: 1.2em;
            text-align: center;
            padding: 10px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #log-panel {
            height: 300px;
            overflow-y: auto;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .timestamp {
            color: #999;
            font-size: 0.8em;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        input, textarea {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .activity-area {
            height: 200px;
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Bot Detection System Tester</h1>
            <p>Interact with this page to test the bot detection features</p>
        </header>
        
        <div id="status-indicator" style="background-color: #FFF3CD;">Analyzing behavior...</div>
        
        <div class="actions">
            <button id="run-detection">Run Detection</button>
            <button id="reset-metrics">Reset Metrics</button>
            <button id="simulate-bot">Simulate Bot Activity</button>
        </div>
        
        <div class="dashboard">
            <div class="panel">
                <h2>Behavioral Analysis</h2>
                <div class="metric">
                    <div class="metric-name">Mouse Movement Naturalness:</div>
                    <div class="metric-value">
                        <span id="mouse-naturalness-value">Waiting...</span>
                        <div class="progress-bar">
                            <div id="mouse-naturalness-bar" class="progress-value"></div>
                        </div>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-name">Scroll Behavior:</div>
                    <div class="metric-value">
                        <span id="scroll-behavior-value">Waiting...</span>
                        <div class="progress-bar">
                            <div id="scroll-behavior-bar" class="progress-value"></div>
                        </div>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-name">Keystroke Naturalness:</div>
                    <div class="metric-value">
                        <span id="keystroke-naturalness-value">Waiting...</span>
                        <div class="progress-bar">
                            <div id="keystroke-naturalness-bar" class="progress-value"></div>
                        </div>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-name">Interaction Timing:</div>
                    <div class="metric-value">
                        <span id="interaction-timing-value">Waiting...</span>
                        <div class="progress-bar">
                            <div id="interaction-timing-bar" class="progress-value"></div>
                        </div>
                    </div>
                </div>
                <div class="metric">
                    <div class="metric-name">Copy/Paste Count:</div>
                    <div class="metric-value" id="copy-paste-count">0</div>
                </div>
                <div class="metric">
                    <div class="metric-name">Page Focus Time:</div>
                    <div class="metric-value" id="page-focus-time">0 seconds</div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Fingerprinting Results</h2>
                <div class="metric">
                    <div class="metric-name">WebGL Fingerprint:</div>
                    <div class="metric-value" id="webgl-fingerprint">Waiting...</div>
                </div>
                <div class="metric">
                    <div class="metric-name">Canvas Fingerprint:</div>
                    <div class="metric-value" id="canvas-fingerprint">Waiting...</div>
                </div>
                <div class="metric">
                    <div class="metric-name">Audio Fingerprint:</div>
                    <div class="metric-value" id="audio-fingerprint">Waiting...</div>
                </div>
                <div class="metric">
                    <div class="metric-name">Screen Metrics:</div>
                    <div class="metric-value" id="screen-metrics">Waiting...</div>
                </div>
                <div class="metric">
                    <div class="metric-name">Detected Fonts:</div>
                    <div class="metric-value" id="detected-fonts">Waiting...</div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Network Information</h2>
            <div class="metric">
                <div class="metric-name">IP Address:</div>
                <div class="metric-value" id="ip-address">Detecting...</div>
            </div>
            <div class="metric">
                <div class="metric-name">Connection Type:</div>
                <div class="metric-value" id="connection-type">Detecting...</div>
            </div>
            <div class="metric">
                <div class="metric-name">WebRTC Leaks:</div>
                <div class="metric-value" id="webrtc-leaks">Checking...</div>
            </div>
            <div class="metric">
                <div class="metric-name">Connection Speed:</div>
                <div class="metric-value" id="connection-speed">Measuring...</div>
            </div>
        </div>
        
        <div class="activity-area" id="mouse-activity-area">
            Move your mouse around in this area
        </div>
        
        <div class="activity-area" id="keystroke-activity-area" tabindex="0">
            Click here and type something to test keystroke analysis
        </div>
        
        <form id="test-form">
            <h2>Test Form (with honeypot)</h2>
            <input type="text" placeholder="Name" name="name">
            <input type="email" placeholder="Email" name="email">
            <textarea placeholder="Message" name="message"></textarea>
            <!-- No submit button - we'll handle submission via JavaScript -->
        </form>
        
        <div class="panel">
            <h2>Event Log</h2>
            <div id="log-panel"></div>
        </div>
    </div>

    <script>
    // Paste your BotDetectionSystem class code here
    class BotDetectionSystem {
        constructor(config = {}) {
            // Configuration options with default settings
            this.config = {
            // Behavioral analysis thresholds
            behavioralThresholds: {
                mouseMovementNaturalness: 0.7,
                scrollSpeedVariance: 0.5,
                keystrokeNaturalness: 0.8,
                interactionTimingVariance: 0.6,
                pageFocusRatio: 0.5,
                copyPasteCount: 3 // Max allowed copy-paste actions
            },
            
            // Network and connection controls
            networkControls: {
                blockKnownProxies: true,
                checkWebRTC: true,
                tcpFingerprintingStrict: true,
                checkConnectionSpeed: true
            },
            
            // Fallback mechanisms for when JavaScript is disabled
            fallbackMethods: {
                headerAnalysis: true,
                ipBlacklist: true,
                captchaVerification: true,
                sessionTracking: true
            },
            ...config
            };

            // Initialize detection mechanisms
            this.initializeBehavioralTracking();
            this.initializeFingerprinting();
            this.initializeNetworkControls();
            this.initializeCookieStorage();
        }

        // Behavioral Analysis Mechanisms
        initializeBehavioralTracking() {
            this.behavioralData = {
            mouseMovements: [],
            scrollEvents: [],
            keystrokePatterns: [],
            pageInteractions: [],
            pageFocusTime: 0,
            copyPasteCount: 0,
            lastActivity: Date.now()
            };

            // Mouse movement tracking
            document.addEventListener('mousemove', (e) => {
            this.trackMouseMovement(e);
            });

            // Scroll behavior tracking
            document.addEventListener('scroll', (e) => {
            this.trackScrollBehavior(e);
            });

            // Keystroke analysis
            document.addEventListener('keydown', (e) => {
            this.analyzeKeystrokes(e);
            });

            // Page focus and interaction tracking
            document.addEventListener('visibilitychange', () => {
            this.trackPageFocus();
            });

            // Click tracking
            document.addEventListener('click', (e) => {
            this.trackInteraction('click', e);
            });

            // Copy paste detection
            document.addEventListener('copy', () => {
            this.behavioralData.copyPasteCount++;
            });
            
            document.addEventListener('paste', () => {
            this.behavioralData.copyPasteCount++;
            });

            // Track page activity time
            setInterval(() => {
            if (document.visibilityState === 'visible') {
                this.behavioralData.pageFocusTime += 1;
            }
            }, 1000);
        }

        trackMouseMovement(event) {
            const timestamp = Date.now();
            const movement = {
            x: event.clientX,
            y: event.clientY,
            timestamp
            };
            
            // Limit array size to prevent memory issues
            if (this.behavioralData.mouseMovements.length > 100) {
            this.behavioralData.mouseMovements.shift();
            }
            
            this.behavioralData.mouseMovements.push(movement);
            this.behavioralData.lastActivity = timestamp;

            // Analyze mouse movement naturalness
            return this.assessMouseMovementNaturalness();
        }

        trackScrollBehavior(event) {
            const timestamp = Date.now();
            const scrollData = {
            scrollY: window.scrollY,
            timestamp
            };
            
            // Limit array size
            if (this.behavioralData.scrollEvents.length > 50) {
            this.behavioralData.scrollEvents.shift();
            }
            
            this.behavioralData.scrollEvents.push(scrollData);
            this.behavioralData.lastActivity = timestamp;
            
            return this.assessScrollBehavior();
        }

        assessScrollBehavior() {
            const scrollEvents = this.behavioralData.scrollEvents;
            if (scrollEvents.length < 5) return true;

            // Calculate variance in scroll speeds
            let scrollSpeeds = [];
            for (let i = 1; i < scrollEvents.length; i++) {
            const timeDiff = scrollEvents[i].timestamp - scrollEvents[i-1].timestamp;
            const scrollDiff = Math.abs(scrollEvents[i].scrollY - scrollEvents[i-1].scrollY);
            
            if (timeDiff > 0) {
                scrollSpeeds.push(scrollDiff / timeDiff);
            }
            }

            if (scrollSpeeds.length < 3) return true;
            
            // Calculate variance
            const avgSpeed = scrollSpeeds.reduce((a, b) => a + b, 0) / scrollSpeeds.length;
            const variance = scrollSpeeds.reduce((a, b) => a + Math.pow(b - avgSpeed, 2), 0) / scrollSpeeds.length;
            const normalizedVariance = Math.min(variance / avgSpeed, 1);
            
            return normalizedVariance >= this.config.behavioralThresholds.scrollSpeedVariance;
        }

        assessMouseMovementNaturalness() {
            const movements = this.behavioralData.mouseMovements;
            if (movements.length < 10) return true;

            // Check for completely straight lines (bot indicator)
            let straightLineCount = 0;
            for (let i = 2; i < movements.length; i++) {
            const p1 = movements[i-2];
            const p2 = movements[i-1];
            const p3 = movements[i];
            
            // Calculate if three points form a straight line
            const slope1 = p1.x !== p2.x ? (p2.y - p1.y) / (p2.x - p1.x) : null;
            const slope2 = p2.x !== p3.x ? (p3.y - p2.y) / (p3.x - p2.x) : null;
            
            // If both slopes are null (vertical lines) or they're equal
            if ((slope1 === null && slope2 === null) || 
                (slope1 !== null && slope2 !== null && Math.abs(slope1 - slope2) < 0.01)) {
                straightLineCount++;
            }
            }
            
            const straightLineRatio = straightLineCount / (movements.length - 2);
            const naturalnessFactor = 1 - straightLineRatio;
            
            return naturalnessFactor >= this.config.behavioralThresholds.mouseMovementNaturalness;
        }

        analyzeKeystrokes(event) {
            const timestamp = Date.now();
            const keystroke = {
            key: event.key,
            keyCode: event.keyCode,
            timestamp,
            timeSinceLast: this.behavioralData.keystrokePatterns.length > 0 ? 
                timestamp - this.behavioralData.keystrokePatterns[this.behavioralData.keystrokePatterns.length - 1].timestamp : 0
            };
            
            // Limit array size
            if (this.behavioralData.keystrokePatterns.length > 50) {
            this.behavioralData.keystrokePatterns.shift();
            }
            
            this.behavioralData.keystrokePatterns.push(keystroke);
            this.behavioralData.lastActivity = timestamp;
            
            return this.assessKeystrokeNaturalness();
        }

        assessKeystrokeNaturalness() {
            const keystrokes = this.behavioralData.keystrokePatterns;
            if (keystrokes.length < 10) return true;
            
            // Check timing patterns of keystrokes
            let timings = keystrokes.map(k => k.timeSinceLast).filter(t => t > 0);
            if (timings.length < 5) return true;
            
            // Calculate variance in timing (humans have more variance)
            const avgTiming = timings.reduce((a, b) => a + b, 0) / timings.length;
            const variance = timings.reduce((a, b) => a + Math.pow(b - avgTiming, 2), 0) / timings.length;
            const normalizedVariance = Math.min(variance / avgTiming, 1);
            
            // Check for perfectly timed keystrokes (bot indicator)
            let perfectTimingCount = 0;
            for (let i = 1; i < timings.length; i++) {
            if (Math.abs(timings[i] - timings[i-1]) < 5) { // 5ms tolerance
                perfectTimingCount++;
            }
            }
            
            const perfectTimingRatio = perfectTimingCount / (timings.length - 1);
            const naturalnessFactor = (1 - perfectTimingRatio) * normalizedVariance;
            
            return naturalnessFactor >= this.config.behavioralThresholds.keystrokeNaturalness;
        }

        trackPageFocus() {
            const timestamp = Date.now();
            const focusEvent = {
            isVisible: document.visibilityState === 'visible',
            timestamp
            };
            
            this.behavioralData.pageInteractions.push(focusEvent);
            this.behavioralData.lastActivity = timestamp;
        }

        trackInteraction(type, event) {
            const timestamp = Date.now();
            const interaction = {
            type,
            x: event.clientX,
            y: event.clientY,
            timestamp,
            timeSinceLast: this.behavioralData.pageInteractions.length > 0 ? 
                timestamp - this.behavioralData.pageInteractions[this.behavioralData.pageInteractions.length - 1].timestamp : 0
            };
            
            // Limit array size
            if (this.behavioralData.pageInteractions.length > 50) {
            this.behavioralData.pageInteractions.shift();
            }
            
            this.behavioralData.pageInteractions.push(interaction);
            this.behavioralData.lastActivity = timestamp;
            
            return this.assessInteractionTiming();
        }

        assessInteractionTiming() {
            const interactions = this.behavioralData.pageInteractions;
            if (interactions.length < 5) return true;
            
            // Filter to only include clicks and other direct interactions
            const directInteractions = interactions.filter(i => i.type === 'click');
            if (directInteractions.length < 3) return true;
            
            // Calculate variance in timing between interactions
            let timings = directInteractions.map(i => i.timeSinceLast).filter(t => t > 0);
            const avgTiming = timings.reduce((a, b) => a + b, 0) / timings.length;
            const variance = timings.reduce((a, b) => a + Math.pow(b - avgTiming, 2), 0) / timings.length;
            const normalizedVariance = Math.min(variance / avgTiming, 1);
            
            return normalizedVariance >= this.config.behavioralThresholds.interactionTimingVariance;
        }

        assessCopyPasteActivity() {
            return this.behavioralData.copyPasteCount <= this.config.behavioralThresholds.copyPasteCount;
        }

        // Fingerprinting Mechanisms
        initializeFingerprinting() {
            this.fingerprintData = {
            webgl: this.captureWebGLFingerprint(),
            canvas: this.captureCanvasFingerprint(),
            audio: this.captureAudioFingerprint(),
            systemResources: this.captureSystemResources(),
            screenMetrics: this.captureScreenMetrics(),
            fonts: this.detectFonts(),
            plugins: this.detectPlugins()
            };
        }

        captureWebGLFingerprint() {
            try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return null;
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (!debugInfo) return null;
            
            // Gather more detailed WebGL data
            return {
                vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
                version: gl.getParameter(gl.VERSION),
                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                antialiasing: gl.getContextAttributes().antialias,
                extensions: gl.getSupportedExtensions(),
                maxAnisotropy: this.getMaxAnisotropy(gl)
            };
            } catch (error) {
            console.error('WebGL fingerprinting failed:', error);
            return null;
            }
        }

        getMaxAnisotropy(gl) {
            try {
            const ext = gl.getExtension('EXT_texture_filter_anisotropic') || 
                        gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || 
                        gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
            return ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            } catch (e) {
            return 0;
            }
        }

        captureCanvasFingerprint() {
            try {
            const canvas = document.createElement('canvas');
            canvas.width = 240;
            canvas.height = 140;
            const ctx = canvas.getContext('2d');
            
            // Text with different characteristics
            const txt = 'BotDetection,Canvas.Fingerprint';
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            
            // Add some complexity to the canvas
            ctx.fillStyle = "#069";
            ctx.font = "15px Arial";
            ctx.fillText(txt, 2, 15);
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.font = "16px Georgia";
            ctx.fillText(txt, 4, 45);
            
            // Draw shapes
            ctx.fillRect(125, 50, 50, 30);
            ctx.beginPath();
            ctx.arc(50, 70, 25, 0, Math.PI * 2, true);
            ctx.fill();
            
            // Get the base64 representation
            return {
                dataURL: canvas.toDataURL(),
                pngDataURL: canvas.toDataURL('image/png'),
                webpDataURL: canvas.toDataURL('image/webp')
            };
            } catch (error) {
            console.error('Canvas fingerprinting failed:', error);
            return null;
            }
        }

        captureAudioFingerprint() {
            try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return null;
            
            const audioCtx = new AudioContext();
            const analyser = audioCtx.createAnalyser();
            const oscillator = audioCtx.createOscillator();
            const dynamicsCompressor = audioCtx.createDynamicsCompressor();
            
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(10000, audioCtx.currentTime);
            
            dynamicsCompressor.threshold.setValueAtTime(-50, audioCtx.currentTime);
            dynamicsCompressor.knee.setValueAtTime(40, audioCtx.currentTime);
            dynamicsCompressor.ratio.setValueAtTime(12, audioCtx.currentTime);
            dynamicsCompressor.attack.setValueAtTime(0, audioCtx.currentTime);
            dynamicsCompressor.release.setValueAtTime(0.25, audioCtx.currentTime);
            
            oscillator.connect(dynamicsCompressor);
            dynamicsCompressor.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            oscillator.start(0);
            
            // Sample the audio buffer
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            // Do cleanup
            oscillator.stop(0);
            audioCtx.close();
            
            // Get a summary hash from the data
            const sum = dataArray.reduce((a, b) => a + b, 0);
            return {
                hash: sum.toString(16),
                sampleRate: audioCtx.sampleRate
            };
            } catch (error) {
            console.error('Audio fingerprinting failed:', error);
            return null;
            }
        }

        captureSystemResources() {
            try {
            // Memory info
            const memoryInfo = performance && performance.memory ? {
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                usedJSHeapSize: performance.memory.usedJSHeapSize
            } : null;
            
            // CPU info - indirect
            const start = performance.now();
            let result = 0;
            for (let i = 0; i < 1000000; i++) {
                result += Math.sqrt(i);
            }
            const end = performance.now();
            const cpuPerformance = end - start;
            
            return {
                memoryInfo,
                cpuPerformance,
                hardwareConcurrency: navigator.hardwareConcurrency || null,
                deviceMemory: navigator.deviceMemory || null
            };
            } catch (error) {
            console.error('System resources fingerprinting failed:', error);
            return null;
            }
        }

        captureScreenMetrics() {
            return {
            width: window.screen.width,
            height: window.screen.height,
            availWidth: window.screen.availWidth,
            availHeight: window.screen.availHeight,
            colorDepth: window.screen.colorDepth,
            pixelDepth: window.screen.pixelDepth,
            devicePixelRatio: window.devicePixelRatio || 1,
            orientation: window.screen.orientation ? window.screen.orientation.type : null
            };
        }

        detectFonts() {
            // A simple font detection mechanism
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const fontList = [
            'Arial', 'Arial Black', 'Arial Narrow', 'Calibri', 'Cambria', 'Cambria Math',
            'Comic Sans MS', 'Courier', 'Courier New', 'Georgia', 'Helvetica', 'Impact',
            'Lucida Console', 'Lucida Sans Unicode', 'Microsoft Sans Serif', 'Palatino Linotype',
            'Segoe UI', 'Tahoma', 'Times', 'Times New Roman', 'Trebuchet MS', 'Verdana'
            ];
            
            const testString = 'mmmmmmmmmmlli';
            const testSize = '72px';
            const h = document.getElementsByTagName('body')[0];
            
            const s = document.createElement('span');
            s.style.fontSize = testSize;
            s.innerHTML = testString;
            const defaultWidth = {};
            const defaultHeight = {};
            
            for (const font of baseFonts) {
            s.style.fontFamily = font;
            h.appendChild(s);
            defaultWidth[font] = s.offsetWidth;
            defaultHeight[font] = s.offsetHeight;
            h.removeChild(s);
            }
            
            const result = [];
            for (const font of fontList) {
            let detected = false;
            for (const baseFont of baseFonts) {
                s.style.fontFamily = font + ', ' + baseFont;
                h.appendChild(s);
                const matched = (s.offsetWidth !== defaultWidth[baseFont] || 
                                s.offsetHeight !== defaultHeight[baseFont]);
                h.removeChild(s);
                if (matched) {
                detected = true;
                break;
                }
            }
            if (detected) {
                result.push(font);
            }
            }
            
            return result;
        }

        detectPlugins() {
            if (!navigator.plugins) return [];
            
            const pluginArray = [];
            for (let i = 0; i < navigator.plugins.length; i++) {
            const plugin = navigator.plugins[i];
            const pluginInfo = {
                name: plugin.name,
                description: plugin.description,
                filename: plugin.filename
            };
            pluginArray.push(pluginInfo);
            }
            
            return pluginArray;
        }

        // Network and Connection Controls
        initializeNetworkControls() {
            this.networkData = {
            ipAddress: null,
            connectionType: this.detectConnectionType(),
            webRTCLeaks: [],
            tcpInfo: null
            };

            this.detectIPAddress();
            if (this.config.networkControls.checkWebRTC) {
            this.checkWebRTCLeaks();
            }
            this.checkConnectionSpeed();
        }

        detectConnectionType() {
            const connection = navigator.connection || 
                            navigator.mozConnection || 
                            navigator.webkitConnection;
            
            if (connection) {
            return {
                type: connection.type,
                effectiveType: connection.effectiveType,
                downlinkMax: connection.downlinkMax,
                downlink: connection.downlink,
                rtt: connection.rtt,
                saveData: connection.saveData
            };
            }
            
            return null;
        }

        detectIPAddress() {
    // Mock IP address for the test page
    this.networkData.ipAddress = new Promise((resolve) => {
        // First try to get IP through WebRTC if enabled
        if (this.config.networkControls.checkWebRTC) {
            const RTCPeerConnection = window.RTCPeerConnection ||
                                    window.webkitRTCPeerConnection ||
                                    window.mozRTCPeerConnection;

            if (RTCPeerConnection) {
                const rtc = new RTCPeerConnection({iceServers: []});
                rtc.createDataChannel('');
                rtc.createOffer()
                    .then(offer => rtc.setLocalDescription(offer))
                    .catch(() => {});

                rtc.onicecandidate = (e) => {
                    if (!e.candidate) return;

                    // Extract IP from candidate string
                    const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/g
                        .exec(e.candidate.candidate);

                    if (ipMatch) {
                        const ip = ipMatch[1];
                        rtc.onicecandidate = null;
                        rtc.close();
                        resolve(ip);
                    }
                };

                // Timeout after 1 second
                setTimeout(() => {
                    rtc.close();
                    resolve(null);
                }, 1000);
            }
        }

        // Fallback to API call
        fetch('https://api.ipify.org?format=json')
            .then(response => response.json())
            .then(data => resolve(data.ip))
            .catch(() => {
                // If all methods fail, use a dummy IP for testing
                resolve('0.0.0.0');
            });
    });
}

checkWebRTCLeaks() {
    if (!this.config.networkControls.checkWebRTC) return;

    const RTCPeerConnection = window.RTCPeerConnection ||
                            window.webkitRTCPeerConnection ||
                            window.mozRTCPeerConnection;

    if (RTCPeerConnection) {
        const rtc = new RTCPeerConnection({
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        });

        rtc.createDataChannel('');

        rtc.createOffer()
            .then(offer => rtc.setLocalDescription(offer))
            .catch(error => {
                console.error('WebRTC check failed:', error);
                this.networkData.webRTCLeaks = [];
            });

        rtc.onicecandidate = (e) => {
            if (!e.candidate) return;

            // Look for different types of candidates
            const candidateString = e.candidate.candidate;
            if (candidateString) {
                if (candidateString.indexOf('typ host') !== -1) {
                    this.networkData.webRTCLeaks.push({
                        type: 'host',
                        candidate: candidateString
                    });
                } else if (candidateString.indexOf('typ srflx') !== -1) {
                    this.networkData.webRTCLeaks.push({
                        type: 'srflx',
                        candidate: candidateString
                    });
                }
            }
        };

        // Cleanup after 2 seconds
        setTimeout(() => {
            rtc.close();
        }, 2000);
    }
}

async checkConnectionSpeed() {
    if (!this.config.networkControls.checkConnectionSpeed) return;

    try {
        const startTime = performance.now();
        const response = await fetch('https://www.google.com/favicon.ico');
        const endTime = performance.now();

        if (response.ok) {
            const duration = endTime - startTime;
            const blob = await response.blob();
            const size = blob.size;
            const speedMbps = (size * 8) / (duration / 1000) / 1000000;

            this.networkData.connectionSpeed = {
                duration: duration,
                size: size,
                speedMbps: speedMbps
            };
        }
    } catch (error) {
        console.error('Connection speed test failed:', error);
        this.networkData.connectionSpeed = null;
    }
}

// Cookie and Storage Management
initializeCookieStorage() {
    this.storageData = {
        cookies: this.checkCookieSupport(),
        localStorage: this.checkLocalStorage(),
        sessionStorage: this.checkSessionStorage()
    };
}

checkCookieSupport() {
    try {
        const testCookie = 'botdetection_test=' + Date.now();
        document.cookie = testCookie;
        const cookieEnabled = document.cookie.indexOf(testCookie) !== -1;
        
        // Clean up test cookie
        document.cookie = 'botdetection_test=; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        
        return cookieEnabled;
    } catch (error) {
        return false;
    }
}

checkLocalStorage() {
    try {
        localStorage.setItem('botdetection_test', 'test');
        localStorage.removeItem('botdetection_test');
        return true;
    } catch (error) {
        return false;
    }
}

checkSessionStorage() {
    try {
        sessionStorage.setItem('botdetection_test', 'test');
        sessionStorage.removeItem('botdetection_test');
        return true;
    } catch (error) {
        return false;
    }
}

// Main Detection Methods
async analyze() {
    const results = {
        behavioral: this.analyzeBehavioralMetrics(),
        fingerprint: this.analyzeFingerprintData(),
        network: await this.analyzeNetworkData(),
        storage: this.analyzeStorageData(),
        timestamp: new Date().toISOString(),
        score: 0,
        isBot: false
    };

    // Calculate final bot detection score
    results.score = this.calculateBotScore(results);
    results.isBot = results.score < 0.5;

    return results;
}

analyzeBehavioralMetrics() {
    return {
        mouseMovement: this.assessMouseMovementNaturalness(),
        scrollBehavior: this.assessScrollBehavior(),
        keystrokePatterns: this.assessKeystrokeNaturalness(),
        interactionTiming: this.assessInteractionTiming(),
        copyPaste: this.assessCopyPasteActivity()
    };
}

analyzeFingerprintData() {
    return {
        webgl: !!this.fingerprintData.webgl,
        canvas: !!this.fingerprintData.canvas,
        audio: !!this.fingerprintData.audio,
        screenMetrics: this.fingerprintData.screenMetrics,
        fonts: this.fingerprintData.fonts.length,
        plugins: this.fingerprintData.plugins.length
    };
}

async analyzeNetworkData() {
    const ipAddress = await this.networkData.ipAddress;
    return {
        ipAddress: ipAddress,
        connectionType: this.networkData.connectionType,
        webRTCLeaks: this.networkData.webRTCLeaks.length,
        connectionSpeed: this.networkData.connectionSpeed
    };
}

analyzeStorageData() {
    return {
        cookiesEnabled: this.storageData.cookies,
        localStorageEnabled: this.storageData.localStorage,
        sessionStorageEnabled: this.storageData.sessionStorage
    };
}

calculateBotScore(results) {
    let score = 0;
    let weights = 0;

    // Behavioral metrics (40% of total score)
    if (results.behavioral.mouseMovement) {
        score += results.behavioral.mouseMovement * 0.15;
        weights += 0.15;
    }
    if (results.behavioral.scrollBehavior) {
        score += results.behavioral.scrollBehavior * 0.1;
        weights += 0.1;
    }
    if (results.behavioral.keystrokePatterns) {
        score += results.behavioral.keystrokePatterns * 0.1;
        weights += 0.1;
    }
    if (results.behavioral.interactionTiming) {
        score += results.behavioral.interactionTiming * 0.05;
        weights += 0.05;
    }

    // Fingerprint data (30% of total score)
    if (results.fingerprint.webgl) score += 0.1;
    if (results.fingerprint.canvas) score += 0.1;
    if (results.fingerprint.audio) score += 0.05;
    if (results.fingerprint.fonts > 5) score += 0.05;
    weights += 0.3;

    // Network data (20% of total score)
    if (results.network.connectionType) score += 0.1;
    if (results.network.webRTCLeaks === 0) score += 0.05;
    if (results.network.connectionSpeed && 
        results.network.connectionSpeed.speedMbps > 0.1) score += 0.05;
    weights += 0.2;

    // Storage data (10% of total score)
    if (results.storage.cookiesEnabled) score += 0.04;
    if (results.storage.localStorageEnabled) score += 0.03;
    if (results.storage.sessionStorageEnabled) score += 0.03;
    weights += 0.1;

    // Normalize score based on available weights
    return weights > 0 ? score / weights : 0;
}
}
